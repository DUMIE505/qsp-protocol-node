#!/usr/bin/env python

import argparse
import json
import sys


class MyhtrilIssue:
    """
    A replica of the issue class from the Mythril repository on Github with some added custom code
    https://github.com/ConsenSys/mythril/blob/master/mythril/analysis/report.py
    """

    def __init__(self, contract, function, address, title, _type="Informational", description="",
                 debug=""):
        self.title = title
        self.contract = contract
        self.function = function
        self.address = address
        self.description = description
        self.type = _type
        self.debug = debug
        self.filename = None
        self.code = None
        self.lineno = None

    def as_dict(self):
        """Retained for documentation purposes only. Filename, lineno and code are optional."""
        issue = {'title': self.title, 'description': self.description, 'function': self.function,
                 'type': self.type, 'address': self.address, 'debug': self.debug}
        if self.filename and self.lineno:
            issue['filename'] = self.filename
            issue['lineno'] = self.lineno
        if self.code:
            issue['code'] = self.code
        return issue

    def as_vulnerability(self, ref_id, vulnerability_mapping):
        vulnerability = self.title
        solidity_file = self.filename
        contract_name = self.contract
        # coverage is not available in mythril
        # coverage = 11.1234
        qsp_type = "other"
        try:
            qsp_type = vulnerability_mapping[self.title]
        except KeyError:
            if "to a user-supplied address" in self.title:
                # This title is dynamically generated by Mythril and contains the type of the call
                qsp_type = "call_to_a_user-supplied_address"
            else:
                # We cannot map this name, the vulnerability name must be new in mythril
                pass

        vulnerability_report = {
            'name': vulnerability,
            'type': qsp_type,
            'file': solidity_file,
            'description': self.description,
        }
        if contract_name is not None:
            vulnerability_report['contract'] = contract_name
        instances_found = [{
            'ref_id': ref_id,
            'start_line': self.lineno,
        }]
        vulnerability_report['instances'] = instances_found
        return vulnerability_report

    @staticmethod
    def from_dict(**dictionary):
        issue = MyhtrilIssue(None, None, None, None)
        issue.__dict__.update(dictionary)
        return issue


def load_list(input_list):
    """
    Loads a list of single-line items from a file
    """
    with open(input_list) as f:
        lines = f.read().splitlines()

    return lines


def main(argv):
    if len(argv) < 2:
        print("Error: expecting at least one .json file as input")

    parser = argparse.ArgumentParser(description='Report formatting of Mythril results')

    parser.add_argument(
        'mythril_version',
        metavar='mythril_version',
        type=str,
        help='mythril version used in producing the report'
    )
    parser.add_argument(
        'cmd',
        metavar='mythril_command',
        type=str,
        help='command used when invoking mythril'
    )
    parser.add_argument(
        'vulnerabilities',
        metavar='vulnerabilities',
        type=str,
        help='file containing all vulnerability names (one per line) supported in this version of mythril'
    )
    parser.add_argument(
        'solidity_files',
        metavar='solidity_files',
        nargs='+',
        type=str,
        help='solidity files to be analyzed'
    )

    # Validates input arguments
    args = parser.parse_args()
    vulnerability_pairs = load_list(args.vulnerabilities)
    vulnerability_types = [x.split("=")[1] for x in vulnerability_pairs]
    vulnerability_names = [x.split("=")[0] for x in vulnerability_pairs]
    vulnerability_mapping = {}
    for i in range(len(vulnerability_names)):
        vulnerability_mapping[vulnerability_names[i]] = vulnerability_types[i]

    # Declares final_report dictionary
    final_report = {
        'analyzer': {
            'name': 'mythril',
            'version': args.mythril_version,
            'vulnerabilities_checked': vulnerability_types,
            'command': args.cmd,
        },
        'status': 'success',
        'potential_vulnerabilities': []
    }

    # starts converting issues
    issue_reference = 0
    potential_vulnerabilities = []
    for report in argv[4:]:
        report_file = open(report)
        report_dict = json.loads(report_file.read())
        report_file.close()
        if report_dict['success']:
            for issue in report_dict['issues']:
                mythril_issue = MyhtrilIssue.from_dict(**issue)
                vulnerability = mythril_issue.as_vulnerability(issue_reference, vulnerability_mapping)
                potential_vulnerabilities.append(vulnerability)
                issue_reference += 1

    # adds suspected vulnerabilities and prints the result
    final_report['potential_vulnerabilities'] = potential_vulnerabilities
    final_report['count_potential_vulnerabilities'] = issue_reference

    print(json.dumps(final_report, indent=2))


if __name__ == "__main__":
    main(sys.argv)
